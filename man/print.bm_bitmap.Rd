% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/print.bm_bitmap.R
\docType{data}
\name{print.bm_bitmap}
\alias{print.bm_bitmap}
\alias{format.bm_bitmap}
\alias{px_unicode}
\alias{px_ascii}
\alias{px_auto}
\title{Print bitmap objects}
\format{
An object of class \code{character} of length 20.

An object of class \code{character} of length 20.
}
\usage{
\method{print}{bm_bitmap}(x, ...,
                     px = getOption("bittermelon.px", px_auto()),
                     fg = getOption("bittermelon.fg", FALSE),
                     bg = getOption("bittermelon.bg", FALSE),
                     compress = getOption("bittermelon.compress", "none"))

\method{format}{bm_bitmap}(x, ...,
                      px = getOption("bittermelon.px", px_auto()),
                      fg = getOption("bittermelon.fg", FALSE),
                      bg = getOption("bittermelon.bg", FALSE),
                      compress = getOption("bittermelon.compress", "none"))

px_unicode

px_ascii

px_auto(unicode = px_unicode, ascii = px_ascii)
}
\arguments{
\item{x}{A \code{bm_bitmap()} object}

\item{...}{Further arguments passed to or from other methods.}

\item{px}{Character vector of the pixel to use for each integer value i.e.
The first character for integer \code{0L},
the second character for integer \code{1L}, and so on.
Will be recycled.}

\item{fg}{R color strings of foreground colors to use and/or cli ANSI style functions of class \code{cli_ansi_style}.
\code{FALSE} (default) for no foreground colors.
Will be recycled and passed to \code{\link[cli:make_ansi_style]{cli::make_ansi_style()}}.}

\item{bg}{R color strings of background colors to use and/or cli ANSI style functions of class \code{cli_ansi_style}.
\code{FALSE} (default) for no background colors.
Will be recycled and passed to \code{\link[cli:make_ansi_style]{cli::make_ansi_style()}} with \code{bg = TRUE}.}

\item{compress}{If "none" (default) or "n" don't compress first with \code{\link[=bm_compress]{bm_compress()}}.
Otherwise compress first with \code{\link[=bm_compress]{bm_compress()}} passing
the value of \code{compress} as its \code{direction} argument
(i.e. either "vertical" or "v", "horizontal" or "h",
OR "both" or "b").}

\item{unicode}{Character vector to use if \code{\link[cli:is_utf8_output]{cli::is_utf8_output()}} is \code{TRUE}.}

\item{ascii}{Character vector to use if \code{\link[cli:is_utf8_output]{cli::is_utf8_output()}} is \code{FALSE}.}
}
\value{
A character vector of the string representation (\code{print.bm_bitmap()} does this invisibly).
As a side effect \code{print.bm_bitmap()} prints out the string representation to the terminal.
}
\description{
\code{print.bm_bitmap()} prints a representation of bitmap objects to the terminal.
It is a wrapper around \code{format.bm_bitmap()} which converts bitmap objects
to a character vector.
\code{px_unicode} and \code{px_ascii} are builtin character vectors intended for use with the \code{px}
argument (the former contains Unicode \dQuote{Block Elements} while the latter is purely ASCII).
\code{px_auto()} chooses which character vector to use based on whether \code{\link[cli:is_utf8_output]{cli::is_utf8_output()}} is \code{TRUE} or not.
}
\examples{
  font_file <- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
  font <- read_hex(font_file)
  bm_R <- font[[str2ucp("R")]]
  print(bm_R)

  if (cli::is_utf8_output())
    print(bm_R, px = px_unicode, compress = "vertical")

  bm_8 <- font[[str2ucp("8")]]
  bm_8_with_border <- bm_extend(bm_extend(bm_8, left = 1L),
                                sides = 1L, value = 2L)
  print(bm_8_with_border, px = c(".", "@", "X"))

  if (cli::num_ansi_colors() >= 16L) {
    print(bm_8_with_border, px = " ",
          bg = c(cli::bg_br_white, cli::bg_blue, cli::bg_red))
  }
}
\seealso{
\code{\link[=bm_bitmap]{bm_bitmap()}}
}
\keyword{datasets}
